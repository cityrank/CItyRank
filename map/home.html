<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CityRank Web</title>
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.js"></script>
    <script src="https://cdn.apple-cloudkit.com/ck/2/cloudkit.js"></script>
<style>
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
    }
    #map {
        width: 100%;
        height: 100vh;
    }
</style>
</head>
<body>
    <div id="map"></div>
    <script>
        // Initialize CloudKit
        CloudKit.configure({
            containers: [{
                containerIdentifier: 'iCloud.com.mikita.mapapp',
                apiTokenAuth: { apiToken: '598d528768fec35ae10417d3313fd4ae6fc6c65907a2e2e7bf88491f0eff9d0a', persist: true },
                environment: 'production'
            }]
        });

const cloudKitToken = cloudKitTokenParts.join('');

CloudKit.configure({
    containers: [{
        containerIdentifier: 'iCloud.com.mikita.mapapp',
        apiTokenAuth: { apiToken: cloudKitToken, persist: true },
        environment: 'production'
    }]
});


     // Initialize Mapbox
        mapboxgl.accessToken = 'pk.eyJ1IjoibWlraXRrbzEiLCJhIjoiY20wemJxaDVzMDVheDJqczg0NnV3MG1jbyJ9.8MNS07csgIJkUXTGjZiaYA';
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/streets-v11',
            center: [0, 0],
            zoom: 2,
            projection: 'globe'
        });



                // Add Navigation Control
        const navControl = new mapboxgl.NavigationControl();
        map.addControl(navControl, 'top-right'); // Position the navigation control at the top-right corner

        // Add Geolocation Control
        const geoLocateControl = new mapboxgl.GeolocateControl({
            positionOptions: { enableHighAccuracy: true },
            trackUserLocation: true,
            showUserHeading: true
        });
        map.addControl(geoLocateControl, 'top-left'); // Position the geolocation control at the top-left corner


        // Apply globe settings, atmosphere, and adjust appearance of layers
        map.on('style.load', () => {
            map.setFog({
                color: 'rgba(135, 206, 235, 0.5)',
                "high-color": 'rgba(70, 130, 180, 0.8)',
                "space-color": 'rgba(20, 24, 82, 1.0)',
                "horizon-blend": 0.1,
                "star-intensity": 0.1
            });

            map.setMinZoom(2.0);
            map.setMaxZoom(11.0);

            // Hide non-essential layers
            const layersToHide = [
                "national-park", "landuse", "pitch-outline",
                "aeroway-polygon", "aeroway-line",
                "building-outline", "building",
                "tunnel-street-minor-low", "tunnel-street-minor-case",
                "tunnel-primary-secondary-tertiary-case", "tunnel-major-link-case",
                "tunnel-motorway-trunk-case", "tunnel-construction",
                "tunnel-path", "tunnel-steps",
                "tunnel-major-link", "tunnel-pedestrian",
                "tunnel-street-minor", "tunnel-primary-secondary-tertiary",
                "tunnel-oneway-arrow-blue", "tunnel-motorway-trunk",
                "tunnel-oneway-arrow-white",
                "ferry", "ferry-auto",
                "road-path-bg", "road-steps-bg",
                "turning-feature-outline", "road-pedestrian-case",
                "road-minor-low", "road-street-low",
                "road-minor-case", "road-street-case",
                "road-secondary-tertiary-case", "road-primary-case",
                "road-major-link-case", "road-motorway-trunk-case",
                "road-construction", "road-path",
                "road-steps", "road-major-link",
                "road-pedestrian", "road-pedestrian-polygon-fill",
                "road-pedestrian-polygon-pattern", "road-polygon",
                "road-minor", "road-street",
                "road-secondary-tertiary", "road-primary",
                "road-oneway-arrow-blue", "road-motorway-trunk",
                "road-rail", "road-rail-tracks",
                "level-crossing", "road-oneway-arrow-white",
                "turning-feature", "golf-hole-line",
                "bridge-path-bg", "bridge-steps-bg",
                "bridge-pedestrian-case", "bridge-street-minor-low",
                "bridge-street-minor-case", "bridge-primary-secondary-tertiary-case",
                "bridge-major-link-case", "bridge-motorway-trunk-case",
                "bridge-construction", "bridge-path",
                "bridge-steps", "bridge-major-link",
                "bridge-pedestrian", "bridge-street-minor",
                "bridge-primary-secondary-tertiary", "bridge-oneway-arrow-blue",
                "bridge-motorway-trunk", "bridge-rail",
                "bridge-rail-tracks", "bridge-major-link-2-case",
                "bridge-motorway-trunk-2-case", "bridge-major-link-2",
                "bridge-motorway-trunk-2", "bridge-oneway-arrow-white",
                "aerialway",
                "building-number-label", "road-label",
                "road-number-shield", "road-exit-shield",
                "golf-hole-label",
                "natural-line-label", "natural-point-label",
                "poi-label", "transit-label",
                "airport-label", "settlement-subdivision-label",
                "state-label", "water-line-label", "water-point-label", "waterway-label", "admin-1-boundary", "admin-1-boundary-bg"
            ];

            layersToHide.forEach(layerId => {
                if (map.getLayer(layerId)) {
                    map.setLayoutProperty(layerId, 'visibility', 'none');
                }
            });

            map.getStyle().layers.forEach(layer => {
                const layerId = layer.id.toLowerCase();
                if (layerId.includes('water')) {
                    if (layer.type === 'fill') {
                        map.setPaintProperty(layer.id, 'fill-color', '#d3d3d3');
                    } else if (layer.type === 'line') {
                        map.setPaintProperty(layer.id, 'line-color', '#A9A9A9');
                    }
                }
                if (layer.type === 'fill') {
                    map.setPaintProperty(layer.id, 'fill-color', '#d3d3d3');
                } else if (layer.type === 'line') {
                    map.setPaintProperty(layer.id, 'line-color', '#A9A9A9');
                }
            });
        });

        // Colors based on rating
        const ratingColors = {
            5: '#2ecc71',
            4: '#27ae60',
            3: '#f1c40f',
            2: '#e67e22',
            1: '#e74c3c'
        };

        // Fetch data from CloudKit and plot on the map
        CloudKit.getDefaultContainer().publicCloudDatabase.performQuery({
            recordType: 'CityComment'
        }).then(response => {
            if (response.hasErrors) {
                console.error('CloudKit query failed:', response.errors);
                return;
            }

            const records = response.records;

            const filteredRecords = records.filter(record => {
                const rating = record.fields.rating ? record.fields.rating.value : null;
                return rating !== null && rating !== undefined && !isNaN(rating);
            });

            const countryRatings = {};

            filteredRecords.forEach(record => {
                const cityName = record.fields.cityName ? record.fields.cityName.value : "Unknown City";
                const comment = record.fields.comment ? record.fields.comment.value : "No comment";
                const rating = record.fields.rating.value;
                const countryName = cityName.split(',').pop().trim();

                geocodeCity(cityName).then(coordinate => {
                    if (coordinate) {
                        addCityCircle(coordinate, { cityName, rating, comment });

                        if (!countryRatings[countryName]) {
                            countryRatings[countryName] = { totalRating: 0, count: 0 };
                        }
                        countryRatings[countryName].totalRating += rating;
                        countryRatings[countryName].count++;
                    }
                });
            });

            setTimeout(() => {
                Object.keys(countryRatings).forEach(countryName => {
                    const averageRating = countryRatings[countryName].totalRating / countryRatings[countryName].count;
                    addPolygonForCountry(countryName, averageRating);
                });
            }, 150);
        }).catch(error => {
            console.error('CloudKit query failed:', error);
        });

        // Geocode city name to coordinates
        function geocodeCity(cityName) {
            return fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(cityName)}.json?access_token=${mapboxgl.accessToken}`)
                .then(response => response.json())
                .then(data => {
                    if (data.features && data.features.length > 0) {
                        return data.features[0].geometry.coordinates;
                    }
                    console.error("Failed to geocode:", cityName);
                    return null;
                });
        }

        // Add a circle to the map for each city
function addCityCircle(coordinate, city) {
    const color = ratingColors[Math.round(city.rating)] || '#3498db';

    map.addLayer({
        id: `${city.cityName}-circle`,
        type: 'circle',
        source: {
            type: 'geojson',
            data: {
                type: 'FeatureCollection',
                features: [{
                    type: 'Feature',
                    geometry: { type: 'Point', coordinates: coordinate },
                    properties: {
                        cityName: city.cityName,
                        rating: city.rating,
                        comment: city.comment
                    }
                }]
            }
        },
        paint: {
            // Adjust circle-radius dynamically based on the zoom level
            'circle-radius': [
                'interpolate', ['linear'], ['zoom'],
                2, 4,     // At zoom level 2, circle radius will be 4
                6, 10,    // At zoom level 6, circle radius will be 10
                10, 30    // At zoom level 10 or higher, circle radius will be 20
            ],
            'circle-color': color,
            'circle-opacity': 0.7
        },
        layout: {
            'visibility': map.getZoom() > 4.0 ? 'visible' : 'none'
        }
    });

            map.on('click', `${city.cityName}-circle`, (e) => {
                const features = map.queryRenderedFeatures(e.point, { layers: [`${city.cityName}-circle`] });
                if (features.length) {
                    const cityName = features[0].properties.cityName;
                    const rating = features[0].properties.rating;
                    const comment = features[0].properties.comment;

                    new mapboxgl.Popup()
                        .setLngLat(coordinate)
                        .setHTML(`
                            <strong>City:</strong> ${cityName}<br>
                            <strong>Rating:</strong> ${rating}<br>
                            <strong>Comment:</strong> ${comment || 'No comment'}
                        `)
                        .addTo(map);
                }
            });
        }

        function addPolygonForCountry(countryName, rating) {
            if (countryName === "Czech Republic") {
                countryName = "Czechia";
            }

            const color = ratingColors[Math.round(rating)] || '#3498db';

            const sourceId = `${countryName}-boundary-source`;
            const layerId = `${countryName}-boundary-layer`;

            if (map.getLayer(layerId)) {
                map.removeLayer(layerId);
            }
            if (map.getSource(sourceId)) {
                map.removeSource(sourceId);
            }

            map.addSource(sourceId, {
                type: 'vector',
                url: 'mapbox://mapbox.country-boundaries-v1'
            });

            map.addLayer({
                id: layerId,
                type: 'fill',
                source: sourceId,
                'source-layer': 'country_boundaries',
                paint: {
                    'fill-color': color,
                    'fill-opacity': 0.7
                },
                layout: {
                    'visibility': map.getZoom() <= 4.0 ? 'visible' : 'none'
                },
                filter: ['==', 'name_en', countryName]
            });
        }

        // Toggle visibility based on zoom level
        map.on('zoom', () => {
            const currentZoom = map.getZoom();
            const countryVisibility = currentZoom <= 4.0 ? 'visible' : 'none';
            const cityVisibility = currentZoom > 4.0 ? 'visible' : 'none';

            // Set visibility for country polygons
            map.getStyle().layers.forEach(layer => {
                if (layer.id.includes('-boundary-layer')) {
                    map.setLayoutProperty(layer.id, 'visibility', countryVisibility);
                }
                if (layer.id.includes('-circle')) {
                    map.setLayoutProperty(layer.id, 'visibility', cityVisibility);
                }
            });
        });
    </script>
</body>
</html>
